<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>StorkOracle — Double-sided ID Badge Generator (with Slot)</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root{
    --navy:#001F3F;
    --cyan:#A5F8FF;
    --slot:#E0F9FF;
    --muted:#BCC8D0;
    --card-w:560px;
    --card-h:320px;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;background:#071226;color:#e6f0f5;}
  .wrap{max-width:1100px;margin:28px auto;padding:20px;}
  h1{font-weight:700;margin:0 0 18px;color:var(--cyan);text-align:center}
  .content{display:flex;gap:28px;align-items:flex-start;flex-wrap:wrap;justify-content:center}
  .panel{background:#071A2B;padding:18px;border-radius:12px;box-shadow:0 8px 30px rgba(2,10,20,0.6);min-width:320px;}
  form{display:flex;flex-direction:column;gap:8px;min-width:280px}
  label{font-size:13px;color:var(--muted);margin-top:6px}
  input[type="text"], input[type="url"], input[type="file"]{padding:10px;border-radius:8px;border:1px solid rgba(165,248,255,0.08);background:#071726;color:#eaf6fb;outline:none}
  .controls{display:flex;gap:8px;margin-top:8px}
  button{cursor:pointer;padding:10px 14px;border-radius:10px;border:none;font-weight:600}
  .btn-generate{background:linear-gradient(90deg,var(--cyan),#7fe7ff);color:#001;box-shadow:0 6px 18px rgba(165,248,255,0.08)}
  .btn-download{background:transparent;border:2px solid var(--cyan);color:var(--cyan);}
  .hint{font-size:12px;color:var(--muted);margin-top:6px}
  /* Card flip scene */
  .scene{width:var(--card-w);height:var(--card-h);perspective:1400px;margin:8px auto;cursor:pointer}
  .card{width:100%;height:100%;position:relative;transform-style:preserve-3d;transition:transform .9s cubic-bezier(.2,.9,.3,1);}
  .card.flipped{transform:rotateY(180deg);}
  .side{position:absolute;inset:0;border-radius:14px;box-shadow:0 8px 30px rgba(0,0,0,0.6);backface-visibility:hidden;overflow:hidden;}
  .side canvas{display:block;width:100%;height:100%;border-radius:14px;}
  .backside{transform:rotateY(180deg);}
  .meta{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:6px;color:var(--muted);font-size:13px}
  @media (max-width:880px){
    .content{flex-direction:column;align-items:center}
    .scene{transform:scale(.9)}
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>StorkOracle — Double-sided ID Badge Generator</h1>
    <div class="content">
      <div class="panel" style="flex:0 0 380px;">
        <form id="badgeForm" autocomplete="off" novalidate>
          <label for="handle">X Handle (include @ or not)</label>
          <input id="handle" type="text" placeholder="@RielRevs" required value="">

          <label for="aka">Nickname (A.k.a)</label>
          <input id="aka" type="text" placeholder="e.g. The Oracle">

          <label for="role">Discord Role</label>
          <input id="role" type="text" placeholder="Community Member" required value="Community Member">

          <label for="pfpFile">Profile Picture (upload preferred)</label>
          <input id="pfpFile" type="file" accept="image/*">

          <label for="pfpUrl">Or paste image URL (may be blocked by CORS)</label>
          <input id="pfpUrl" type="url" placeholder="https://...">

          <div class="controls">
            <button id="generateBtn" type="button" class="btn-generate">Generate Preview</button>
            <button id="downloadBtn" type="button" class="btn-download">Download Badge</button>
          </div>
          <div class="hint">Tip: For guaranteed download, use the <strong>Upload</strong> option for profile pictures. Click the card to flip.</div>
        </form>
      </div>

      <div style="flex:0 0 560px; text-align:center;">
        <div class="scene" id="scene" title="Click to flip (front/back)">
          <div class="card" id="card" aria-hidden="false">
            <div class="side front" aria-hidden="false">
              <canvas id="frontCanvas" width="560" height="320" aria-label="Front side preview"></canvas>
            </div>
            <div class="side back backside" aria-hidden="true">
              <canvas id="backCanvas" width="560" height="320" aria-label="Back side preview"></canvas>
            </div>
          </div>
        </div>
        <div class="meta">Click the badge to flip • Front shows handle, role, nickname & photo • Back shows handle, role & barcode</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // Design constants (CSS pixels)
  const CARD_W = 560;
  const CARD_H = 320;
  const GAP = 18;
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // Colors
  const NAVY = '#001F3F';
  const CYAN = '#A5F8FF';
  const SLOT = '#E0F9FF';
  const WHITE = '#FFFFFF';
  const MUTED = '#BCC8D0';

  // Elements
  const frontCanvas = document.getElementById('frontCanvas');
  const backCanvas = document.getElementById('backCanvas');
  const cardEl = document.getElementById('card');
  const scene = document.getElementById('scene');
  const form = document.getElementById('badgeForm');
  const generateBtn = document.getElementById('generateBtn');
  const downloadBtn = document.getElementById('downloadBtn');

  // Inputs
  const inputHandle = document.getElementById('handle');
  const inputRole = document.getElementById('role');
  const inputAka = document.getElementById('aka');
  const inputPfpFile = document.getElementById('pfpFile');
  const inputPfpUrl = document.getElementById('pfpUrl');

  // Prepare canvases for high DPI
  function prepareCanvas(canvas){
    canvas.width = CARD_W * DPR;
    canvas.height = CARD_H * DPR;
    canvas.style.width = CARD_W + 'px';
    canvas.style.height = CARD_H + 'px';
    const ctx = canvas.getContext('2d');
    ctx.setTransform(DPR,0,0,DPR,0,0);
    return ctx;
  }
  const fctx = prepareCanvas(frontCanvas);
  const bctx = prepareCanvas(backCanvas);

  function roundRectPath(ctx, x, y, w, h, r) {
    if (r < 0) r = 0;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // Load image helper (supports dataURL and URLs). Uses crossOrigin for remote urls.
  function loadImage(src){
    return new Promise((resolve, reject) => {
      if (!src) return reject(new Error('no-src'));
      const img = new Image();
      if (/^https?:\/\//i.test(src)) {
        img.crossOrigin = 'anonymous';
      }
      img.onload = () => resolve(img);
      img.onerror = (e) => reject(e);
      img.src = src;
    });
  }

  // Draw a single card side into ctx using data
  function drawCard(ctx, data, side='front'){
    // clear
    ctx.clearRect(0,0,CARD_W,CARD_H);

    // background with subtle gradient
    const g = ctx.createLinearGradient(0,0,CARD_W,CARD_H);
    g.addColorStop(0, NAVY);
    g.addColorStop(1, '#001426');
    roundRectPath(ctx, 0, 0, CARD_W, CARD_H, 14);
    ctx.fillStyle = g;
    ctx.fill();

    // border
    ctx.lineWidth = 2.5;
    ctx.strokeStyle = CYAN;
    roundRectPath(ctx, 0, 0, CARD_W, CARD_H, 14);
    ctx.stroke();

    // Painted rounded slot (top-center)
    const slotW = Math.round(CARD_W * 0.15); // ~84px
    const slotH = Math.round(CARD_H * 0.04); // ~12px
    const slotX = Math.round((CARD_W - slotW) / 2);
    const slotY = 8; // slightly down from top
    // draw a subtle clip bar behind slot for realism
    const clipW = slotW + 18;
    const clipH = slotH + 10;
    const clipX = Math.round((CARD_W - clipW) / 2);
    const clipY = slotY - Math.round(clipH * 0.5);
    ctx.fillStyle = '#00111a';
    roundRectPath(ctx, clipX, clipY, clipW, clipH, 6);
    ctx.fill();
    // draw slot on top
    ctx.fillStyle = SLOT;
    roundRectPath(ctx, slotX, slotY, slotW, slotH, slotH/2);
    ctx.fill();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = NAVY;
    roundRectPath(ctx, slotX, slotY, slotW, slotH, slotH/2);
    ctx.stroke();

    // Decorative top-left accent (subtle)
    ctx.fillStyle = 'rgba(165,248,255,0.04)';
    ctx.fillRect(16, 16, 120, 12);

    // Common logo draw at bottom-right if available
    const drawLogo = (ctx, logoImg) => {
      if (!logoImg) return;
      const lw = 84, lh = 40;
      ctx.drawImage(logoImg, CARD_W - 16 - lw, CARD_H - 12 - lh, lw, lh);
    };

    if (side === 'front') {
      // Layout: left - circular PFP; right - text lines
      const pad = 28;
      const avatarX = pad + 70;
      const avatarY = CARD_H/2 - 10;
      const avatarR = 68;

      // Avatar (circle mask). If no image, draw initials placeholder
      if (data.pfpImg) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(avatarX, avatarY, avatarR, 0, Math.PI*2);
        ctx.closePath();
        ctx.clip();

        // draw image centered & cropped
        const iw = data.pfpImg.width;
        const ih = data.pfpImg.height;
        const scale = Math.max((avatarR*2)/iw, (avatarR*2)/ih);
        const sw = (avatarR*2)/scale;
        const sh = (avatarR*2)/scale;
        const sx = (iw - sw)/2;
        const sy = (ih - sh)/2;
        ctx.drawImage(data.pfpImg, sx, sy, sw, sh, avatarX - avatarR, avatarY - avatarR, avatarR*2, avatarR*2);
        ctx.restore();

        // subtle ring glow
        ctx.save();
        ctx.beginPath();
        ctx.arc(avatarX, avatarY, avatarR+4, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(165,248,255,0.25)';
        ctx.lineWidth = 6;
        ctx.shadowColor = CYAN;
        ctx.shadowBlur = 14;
        ctx.stroke();
        ctx.restore();
      } else {
        // placeholder circle with gradient
        const pg = ctx.createLinearGradient(avatarX - avatarR, avatarY - avatarR, avatarX + avatarR, avatarY + avatarR);
        pg.addColorStop(0, '#0f2b3d');
        pg.addColorStop(1, '#18394a');
        ctx.fillStyle = pg;
        ctx.beginPath();
        ctx.arc(avatarX, avatarY, avatarR, 0, Math.PI*2);
        ctx.fill();
        // initials
        const initials = (data.aka || data.handle || 'U').split(' ').map(s=>s[0]).slice(0,2).join('').toUpperCase();
        ctx.fillStyle = CYAN;
        ctx.font = '700 28px Inter, Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(initials, avatarX, avatarY);
        ctx.textAlign = 'start';
      }

      // Right side text
      const textX = 220;
      let y = 92;
      // Handle (big)
      ctx.fillStyle = CYAN;
      ctx.font = '700 28px Inter, Arial';
      const handleText = data.handleClean || data.handle || '';
      ctx.fillText(handleText, textX, y);

      // Role (white)
      y += 36;
      ctx.fillStyle = WHITE;
      ctx.font = '600 18px Inter, Arial';
      ctx.fillText(data.role || '', textX, y);

      // A.k.a (muted)
      if (data.aka) {
        y += 30;
        ctx.fillStyle = '#C6D7DE';
        ctx.font = 'italic 16px Inter, Arial';
        ctx.fillText(`A.k.a ${data.aka}`, textX, y);
      }

      // Small arrow accent top-right
      ctx.fillStyle = CYAN;
      ctx.font = 'bold 28px Inter, Arial';
      ctx.fillText('→', CARD_W - 46, 52);

      // optional small subtle ID line near bottom-left
      ctx.fillStyle = 'rgba(165,248,255,0.08)';
      ctx.fillRect(24, CARD_H - 72, 180, 2);

      // draw logo if available
      drawLogo(ctx, data.logoImg);
    } else {
      // BACK SIDE
      // right-side triangular geometric accent
      const gx = ctx.createLinearGradient(CARD_W - 160, 60, CARD_W - 20, CARD_H - 40);
      gx.addColorStop(0, CYAN);
      gx.addColorStop(1, NAVY);
      ctx.beginPath();
      ctx.moveTo(CARD_W - 160, 40);
      ctx.lineTo(CARD_W - 20, CARD_H/2);
      ctx.lineTo(CARD_W - 160, CARD_H - 40);
      ctx.closePath();
      ctx.fillStyle = gx;
      ctx.fill();

      // Handle small
      ctx.fillStyle = WHITE;
      ctx.font = '600 18px Inter, Arial';
      ctx.fillText(data.handleDisplay || data.handle || '', 32, 64);

      // Role
      ctx.fillStyle = CYAN;
      ctx.font = '600 16px Inter, Arial';
      ctx.fillText(data.role || '', 32, 96);

      // A.k.a if present
      if (data.aka) {
        ctx.fillStyle = '#c9d6dd';
        ctx.font = 'italic 14px Inter, Arial';
        ctx.fillText(`A.k.a ${data.aka}`, 32, 124);
      }

      // Barcode region (bottom-left)
      const bx = 32;
      const by = CARD_H - 110;
      const bw = 220;
      const bh = 72;
      // white outline box
      ctx.fillStyle = WHITE;
      ctx.fillRect(bx - 6, by - 8, bw + 12, bh + 16);
      // inner background for bars
      ctx.fillStyle = NAVY;
      ctx.fillRect(bx - 2, by - 4, bw + 4, bh + 8);
      // draw bars
      ctx.fillStyle = WHITE;
      let px = bx;
      for (let i=0;i<28;i++){
        const w = 2 + (i % 3);
        const h = 20 + ((i*7)%50);
        ctx.fillRect(px, by + (bh - h), w, h);
        px += w + 4;
      }

      // logo bottom-right
      drawLogo(ctx, data.logoImg);
    }
  }

  // Toggle flip on click & keyboard
  scene.addEventListener('click', ()=>cardEl.classList.toggle('flipped'));
  scene.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); cardEl.classList.toggle('flipped'); } });
  scene.tabIndex = 0;

  // Build data & draw both sides
  async function renderPreview(){
    const rawHandle = (inputHandle.value || '').trim();
    if (!rawHandle) { alert('Please enter an X handle'); return; }

    const handleDisplay = rawHandle.startsWith('@') ? rawHandle : '@' + rawHandle;
    const handleClean = rawHandle.replace(/^@/, '');

    const role = (inputRole.value || '').trim();
    const aka = (inputAka.value || '').trim();

    // Prepare data
    const data = { handleDisplay, handleClean, role, aka, pfpImg: null, logoImg: null, handle: handleDisplay };

    // Load logo from same folder (stork-logo.png)
    try {
      data.logoImg = await loadImage('stork-logo.png');
    } catch (e) {
      console.warn('Logo not found or blocked:', e);
      data.logoImg = null;
    }

    // Get PFP: file preferred
    const file = inputPfpFile.files[0];
    if (file) {
      // read as dataURL
      const reader = new FileReader();
      reader.onload = async function(ev){
        try {
          data.pfpImg = await loadImage(ev.target.result);
        } catch (err) {
          console.warn('Failed to load pfp data url', err);
        }
        // draw both canvases
        drawCard(fctx, data, 'front');
        drawCard(bctx, data, 'back');
      };
      reader.readAsDataURL(file);
      return;
    }

    // Else try URL if provided
    const url = (inputPfpUrl.value || '').trim();
    if (url) {
      try {
        data.pfpImg = await loadImage(url);
      } catch (e) {
        alert('Could not load image from URL due to CORS or network. Use file upload for guaranteed results.');
        data.pfpImg = null;
      }
    }

    // draw both sides
    drawCard(fctx, data, 'front');
    drawCard(bctx, data, 'back');
  }

  // Hook generate button
  generateBtn.addEventListener('click', renderPreview);

  // Download both sides combined (stacked vertically)
  downloadBtn.addEventListener('click', async ()=>{
    // Ensure preview exists and is up-to-date
    await renderPreview();

    const outCanvas = document.createElement('canvas');
    outCanvas.width = CARD_W * DPR;
    outCanvas.height = (CARD_H * 2 + GAP) * DPR;
    const octx = outCanvas.getContext('2d');
    octx.setTransform(DPR,0,0,DPR,0,0);

    // white background optional - keep transparent background for modern feel
    // draw front at y=0
    octx.drawImage(frontCanvas, 0, 0, CARD_W, CARD_H);
    // draw small gap divider (transparent)
    // draw back at y = CARD_H + GAP
    octx.drawImage(backCanvas, 0, CARD_H + GAP, CARD_W, CARD_H);

    // create download
    const dataURL = outCanvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = 'stork-badge.png';
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

  // Auto-generate a default preview for convenience
  setTimeout(()=>{
    if (!inputHandle.value) inputHandle.value = '@YourHandle';
    renderPreview();
  }, 300);
})();</script>
</body>
</html>
